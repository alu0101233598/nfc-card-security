#!/usr/bin/python3
# -*- encoding: utf-8 -*-

#########################################################################
## This program utilizes Frida to collect random nonces generated by the
## eID. It is necessary for the Android device used along this tool to
## run the Frida server utility as root.
#########################################################################
## Copyright (C) 2022  Javier Correa Marichal
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <https://www.gnu.org/licenses/>.
#########################################################################

import frida, sys, os, signal, json
import hexdump, binascii, argparse


# Global variables
TARGET_PROCESS = 'Sample_Dnie_App'
output_file = None
script = None
counter = 0


def message_handler(message, data):
  global counter
  if message['type'] == 'error':
    if 'de.tsenger.androsmex.e.e' in message['description']:
      print('[E] Please, scan the DNI once so the libraries are loaded in memory!')
      exit(1)
    else:
      print('[E]', message)
  if message['type'] == 'send':
    my_json = json.loads(message['payload'])
    if my_json['type'] == 'encNonce':
      if args.verbose:
        print("[*] Encrypted nonce:")
        hexdump.hexdump(data)
    elif my_json['type'] == 'decNonce':
      if args.verbose:
        print("[*] Decrypted nonce:")
        hexdump.hexdump(data)
        print('------------------')
      if output_file:
        output_file.write(f"{binascii.hexlify(bytearray(data)).decode('ascii')}\n")
    elif my_json['type'] == 'key':
      if args.verbose:
        print("[*] Key:")
        hexdump.hexdump(data)
    elif my_json['type'] == 'poll':
      if args.count:
        counter += 1
        script.post({'condition': counter < args.count})
      else:
        script.post({'condition': True})
    else:
      hexdump.hexdump(data)


def exit(ret):
  print('\n[!] Exiting')
  if output_file:
    output_file.close()
  os._exit(ret)


def sig_handler(sig, frame):
  exit(0)


def attach_frida():
  global script
  print('[H] Attaching to USB device')
  device = frida.get_usb_device()
  print(f'[H] Attaching to target process: {TARGET_PROCESS}')
  process = device.attach(TARGET_PROCESS)
  with open('nonce.js') as jscode:
    script = process.create_script(jscode.read())
  script.on('message', message_handler)
  print(f'[H] Loading JS Frida module')
  script.load()


if __name__ == '__main__':
  signal.signal(signal.SIGINT, sig_handler)
  parser = argparse.ArgumentParser()
  parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
  parser.add_argument("-w", "--write", help="append key dump into file")
  parser.add_argument("-c", "--count", help="number of nonces to be extracted", type=int)
  args = parser.parse_args()
  if args.write:
    output_file = open(args.write, 'a+')
  attach_frida()
  sys.stdin.read()
